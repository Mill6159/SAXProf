import numpy as np

class ERRORPROP:

    def __init__(self, saxs1 = [], I_no_noise = [], I_w_noise = [], I_no_noise_calc = []):
        """
        Description:
        """
        self.saxs1 = saxs1

        # generate buffer profile. simulate_buf uses trimmed mask_q for q-values
        try:
            (synth_buf, MT_cell, Vac_cell, win_cell, buf_cell) = saxs1.simulate_buf(subtracted=True)
        except ValueError as e:  # this essentially says if a ValueError occurs, call it e, extracts the args component
            print(e.args)  # of the instance, and has it printed, and then forces the ValueError to occur.
            raise e

        for c in np.arange(0.05, 5.0, 0.1):
            saxs1.c = c

            # calculate synthetic curve on buf_model profile generated by simulate_buf
            I_no_noise = saxs1.I_of_q(saxs1.c, saxs1.mw, saxs1.buf_model_q)

            # calculate noisy profile on mask_q points that fall within both buf's q range and the specified default_q range (mask_q_short)
            I_w_noise = saxs1.t * saxs1.pixel_size ** 2 * saxs1.with_noise(saxs1.t, saxs1.buf_model_q, I_no_noise)

            # calculated smooth I on default_q (goes all the way to q = 0)
            I_no_noise = saxs1.t * saxs1.pixel_size ** 2 * I_no_noise

            # calculated smooth I and sigma on same q points as I_w_noise
            I_no_noise_calc = saxs1.Icalc * saxs1.t * saxs1.pixel_size ** 2  # in register with buffer

        self.I_no_noise = I_no_noise
        self.I_w_noise = I_w_noise
        self.I_no_noise_calc = I_no_noise_calc

    def calc_errRg(self, imin = [], imax = []):
        saxs1 = self.saxs1
        I_w_noise = self.I_w_noise
        if imin == [] and imax == []:
            conc = []
            errRg = []
            imin = 0
            imax = 90
            log_sigma = np.abs(saxs1.sigma / I_w_noise)  # converts sigma of the variable to sigma for log of the variable

            (inter, slope, sig2_inter, sig2_slope) = saxs1.lsqfity_with_sigmas(saxs1.buf_model_q[imin:imax] ** 2, np.log(I_w_noise[imin:imax]),
                                                                               log_sigma[imin:imax])

            Rg = np.sqrt(-3 * slope)
            sig_Rg = np.abs(
                Rg * np.sqrt(sig2_slope) / (2 * slope))  # converts the sigma^2 for the slope to the sigma of Rg

            # err_Rg = np.sqrt(-3*err_slope)
            # print c,Rg,sig_Rg/Rg,Rg*saxs1.buf_model_q[imax]

            conc.append(saxs1.c)
            errRg.append(sig_Rg / Rg)
            print ('Default imin/imax values used: 0 and 90')
            return conc, errRg
        if imin != [] and imax == []:
            conc = []
            errRg = []
            self.imin = imin
            imax = 90
            log_sigma = np.abs(saxs1.sigma / I_w_noise)  # converts sigma of the variable to sigma for log of the variable

            (inter, slope, sig2_inter, sig2_slope) = saxs1.lsqfity_with_sigmas(saxs1.buf_model_q[imin:imax] ** 2, np.log(I_w_noise[imin:imax]),
                                                                               log_sigma[imin:imax])

            Rg = np.sqrt(-3 * slope)
            sig_Rg = np.abs(
                Rg * np.sqrt(sig2_slope) / (2 * slope))  # converts the sigma^2 for the slope to the sigma of Rg

            # err_Rg = np.sqrt(-3*err_slope)
            # print c,Rg,sig_Rg/Rg,Rg*saxs1.buf_model_q[imax]

            conc.append(saxs1.c)
            errRg.append(sig_Rg / Rg)
            print ('imin was changed. Range(imin-imax) = %s - %s' % (str(imin), str(imax)))
            return conc, errRg
        if imin == [] and imax != []:
            conc = []
            errRg = []
            imin = 0
            self.imax = imax
            log_sigma = np.abs(saxs1.sigma / I_w_noise)  # converts sigma of the variable to sigma for log of the variable

            (inter, slope, sig2_inter, sig2_slope) = saxs1.lsqfity_with_sigmas(saxs1.buf_model_q[imin:imax] ** 2, np.log(I_w_noise[imin:imax]),
                                                                               log_sigma[imin:imax])

            Rg = np.sqrt(-3 * slope)
            sig_Rg = np.abs(
                Rg * np.sqrt(sig2_slope) / (2 * slope))  # converts the sigma^2 for the slope to the sigma of Rg

            # err_Rg = np.sqrt(-3*err_slope)
            # print c,Rg,sig_Rg/Rg,Rg*saxs1.buf_model_q[imax]

            conc.append(saxs1.c)
            errRg.append(sig_Rg / Rg)
            print ('imax was changed. Range(imin-imax) = %s - %s' % (str(imin), str(imax)))
            return conc, errRg
        if imin != [] and imax != []:
            conc = []
            errRg = []
            self.imin = imin
            self.imax = imax
            log_sigma = np.abs(saxs1.sigma / I_w_noise)  # converts sigma of the variable to sigma for log of the variable

            (inter, slope, sig2_inter, sig2_slope) = saxs1.lsqfity_with_sigmas(saxs1.buf_model_q[imin:imax] ** 2, np.log(I_w_noise[imin:imax]),
                                                                               log_sigma[imin:imax])

            Rg = np.sqrt(-3 * slope)
            sig_Rg = np.abs(
                Rg * np.sqrt(sig2_slope) / (2 * slope))  # converts the sigma^2 for the slope to the sigma of Rg

            # err_Rg = np.sqrt(-3*err_slope)
            # print c,Rg,sig_Rg/Rg,Rg*saxs1.buf_model_q[imax]

            conc.append(saxs1.c)
            errRg.append(sig_Rg / Rg)
            print ('imin and imax were changed. Range(imin-imax) = %s - %s' % (str(imin), str(imax)))
            return conc, errRg



